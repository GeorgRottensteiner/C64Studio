<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<HEAD>
  <link rel="stylesheet" type="text/css" href="msoffice.css" />
  <Title>C64 Studio</Title>
</HEAD>

<body>
  <H3>Assembler - Pseudo Operations</H3>
  <div id="mybody">
    These pseudo ops are supported in ACME/C64Studio mode:<br />
    <br />
    <br />
    <ul>
      <li><a href="#address">!ADDRESS, !ADDR</a></li>
      <li><a href="#align">!ALIGN</a></li>
      <li><a href="#bank">!BANK</a></li>
      <li><a href="#basic">!BASIC</a></li>
      <li><a href="#binary">!BINARY, !BIN, !BI</a></li>
      <li><a href="#byte">!BYTE, !BY, !8, !08</a></li>
      <li><a href="#convtab">!CONVTAB, !CT</a></li>
      <li><a href="#cpu">!CPU</a></li>
      <li><a href="#dword">!DWORD, !32, !BE32, !LE32</a></li>
      <li><a href="#end">!END</a></li>
      <li><a href="#eof">!ENDOFFILE, !EOF</a></li>
      <li><a href="#error">!ERROR, !SERIOUS</a></li>
      <li><a href="#for">!FOR</a></li>
      <li><a href="#fill">!FILL, !FI</a></li>
      <li><a href="#hex">!HEX, !H</a></li>
      <li><a href="#ifdef">!IFDEF, !IF</a></li>
      <li><a href="#ifndef">!IFNDEF</a></li>
      <li><a href="#jumplist">!JUMPLIST</a></li>
      <li><a href="#list">!LIST</a></li>
      <li><a href="#lzone">!LZONE</a></li>
      <li><a href="#macro">!MACRO</a></li>
      <li><a href="#media">!MEDIA</a></li>
      <li><a href="#mediasrc">!MEDIASRC</a></li>
      <li><a href="#message">!MESSAGE</a></li>
      <li><a href="#nowarn">!NOWARN</a></li>
      <li><a href="#pseudopc">!PSEUDOPC</a></li>
      <li><a href="#realign">!REALIGN</a></li>
      <li><a href="#realpc">!REALPC</a></li>
      <li><a href="#scrxor">!SCRXOR</a></li>
      <li><a href="#set">!SET</a></li>
      <li><a href="#skip">!SKIP</a></li>
      <li><a href="#sl">!SL</a></li>
      <li><a href="#source">!SOURCE, !SRC</a></li>
      <li><a href="#text">!TEXT, !TX, !SCR, !PET, !RAW</a></li>
      <li><a href="#to">!TO</a></li>
      <li><a href="#trace">!TRACE</a></li>
      <li><a href="#warn">!WARN</a></li>
      <li><a href="#while">!WHILE</a></li>
      <li><a href="#word">!WORD, !WO, !16, !BE16, !LE16</a></li>
      <li><a href="#zone">!ZONE, !ZN</a></li>
    </ul>
    <br />
    <br />
  </div>
  <a name="address"></a>
  <H2>!ADDRESS, !ADDR {</H2>
  <div id="mybody">
    This pseudo is currently a noop added for ACME compatibility. Intention: Any labels declared inside are marked as being addresses and will throw a warning when used in immediate addressing opcodes.<br />
    <br />
    <br />
    <div id="code">
      <br />      !address {
      SCREEN_ADDRESS = $0400
      }
    </div>
    <br />
    <br />
  </div>
  <a name="align"></a>
  <H2>!ALIGN &lt;andvalue&gt;,&lt;equalvalue&gt;[,&lt;fillvalue&gt;]</H2>
  <div id="mybody">
    This pseudo op fills memory until a matching address is reached. Fill value is output until program counter and [andvalue] equal [equalvalue].<br />
    If [fillvalue] is omitted 0 is used.<br />
    <br />
    <br />
    <div id="code">
      <br />      !align 1,0       ;wait for even address
      !align 255,0     ;align code to page border
    </div>
    <br />
    <br />
  </div>
  <a name="bank"></a>
  <H2>!BANK &lt;bank index&gt;[,&lt;bank size&gt;]</H2>
  <div id="mybody">
    This pseudo op is for the support of cartridge banks. Any following assembled code is filled to the given bank size when the end of file or another !BANK pseudo op is encountered.<br />
    <br />
    If the size argument is not used the size from a previous !BANK statement will be used.<br />
    <br />
    <br />
    Usually !BANK will be used in conjunction with a !PSEUDOPC.<br />
    <br />
    <br />
    <div id="code">
      <br />      !bank 0,$2000
    </div>
    <br />
    <br />
  </div>
  <a name="basic"></a>
  <H2>!BASIC [,&lt;jump address&gt;]<br />!BASIC &lt;line number&gt;,&lt;label&gt;<br />!BASIC &lt;line number&gt;,&lt;special/tokens,&gt;,&lt;label&gt;</H2>
  <div id="mybody">
    This pseudo op adds a BASIC start line with a sys call to either the given jump address or the first statement after the pseudo op. If not provided otherwise the added BASIC line always has line number 10 and a 4 digit target address. This way the BASIC line will always require 12 bytes.
    If the jump address is 5 decimal digits the line will use 13 bytes.<br />
    <br />
    Note: If !cpu is set to m65 (Mega65) the !basic directive will add a line before the actual SYS call setting the bank to 0 (10 BANK 0). All other parts will be moved to the second line.<br />
    <br />
    If a string comment is used it is appended directly after the SYS number.<br />
    Note: If no colon is added this will result in a syntax error when returning to BASIC.<br />
    <br />
    <br />
    <b>Example #1 - standard, no parameters</b><br />
    <br />
    <div id="code">
      <br />      *=$0801
      ;12 bytes basic sys call
      !basic

      ;SYS call jumps here
      rts
    </div>
    <br />
    BASIC listing looks like:<br />
    <br />
    <div id="code">
      <br />    10 SYS2061
      <br />
    </div>
    <br />
    BASIC listing looks like for !cpu M65:<br />
    <br />
    <div id="code">
      <br />    10 MODE0
      20 SYS2061
    </div>
    <br />
    <br />


    <b>Example #2 - start address</b><br />
    <br />
    <div id="code">
      <br />      *=$0801
      ;12 bytes basic sys call
      !basic init

      init
      ;SYS call jumps here
      rts
    </div>
    <br />
    BASIC listing looks like:<br />
    <br />
    <div id="code">
      <br />    10 SYS2061
    </div>
    <br />
    <br />

    <b>Example #3 - line number and start address</b><br />
    <br />
    <div id="code">
      <br />      *=$0801
      ;12 bytes basic sys call
      !basic 2021, init

      init
      ;SYS call jumps here
      rts
    </div>
    <br />
    BASIC listing looks like:<br />
    <br />
    <div id="code">
      <br />    2021 SYS2061
    </div>
    <br />
    <br />


    <b>Example #4 - full monty, line number, tokens/text and start address</b><br />
    <br />
    <div id="code">
      <br />      *=$0801
      ;29 bytes basic sys call
      ;sys call is followed by colon, a REM token, 4 backspaces to hide them during LIST, and the actual comment
      !basic 2021, ":", $8F, $14,$14,$14,$14, " MY COMMENT", init

      init
      ;SYS call jumps here
      rts
    </div>
    <br />
    BASIC listing looks like:<br />
    <br />
    <div id="code">
      <br />    2021 SYS2061 MY COMMENT
    </div>
    <br />
    <br />
  </div>
  <a name="binary"></a><a name="bin"></a><a name="bi"></a>
  <H2>!BINARY, !BIN, !BI &lt;file name&gt;[,&lt;size&gt;,[&lt;skip&gt;]]</H2>
  <div id="mybody">
    This pseudo op inserts a file as binary data.<br />
    <br />
    &lt;size&gt; sets the number of bytes that are read from the file. If it is not set the whole file is included.<br />
    <br />
    &lt;skip&gt; sets the number of bytes that are skipped from the start of the file. If it is not set no bytes are skipped.<br />
    <br />
    <br />
    <div id="code">
      <br />      !bin "soulless20.bin"
      !binary "music.prg",,2
    </div>
    <br />
    <br />
  </div>
  <a name="byte"></a><a name="by"></a><a name="8"></a><a name="08"></a>
  <H2>!BYTE, !BY, !8, !08</H2>
  <div id="mybody">
    This pseudo op allows to insert one ore more bytes at the current location.<br />
    <br />
    Allowed are constant values, expressions and labels as content.<br />
    Constant values can be set as decimal, hexadecimal (with prefixed $), chars (surrounded by ' or ").<br />
    Labels are treated as 16-bit values. To get the high or low byte prefix the label with &lt; (low byte) or &gt; (high byte)<br />
    Expressions are evaluated during the final pass. They must evaluate to a valid byte value.<br />
    <br />
    <br />
    <div id="code">
      <br />      !byte 1,3,6,3,1
      !byte &lt;NoBehaviour
      !byte ( SCREEN_CHAR + 0 ) & 0x00ff
    </div>
    <br />
    <br />
  </div>
  <a name="convtab"></a><a name="ct"></a>
  <H2>!CONVTAB, !CT &lt;raw/scr/pet/mapping list&gt;</H2>
  <div id="mybody">
    This pseudo op allows sets a conversion table for text in !TEXT entries. You can pass either <b>raw</b>, <b>scr</b> or <b>pet</b> for inbuilt mapping, or provide a manual mapping list.<br />
    <br />
    If RAW is set byte values are inserted as is. Any existing mapping list is cleared.<br />
    <br />
    If SCR is set any byte values are mapped to screen codes. Any existing mapping list is cleared.<br />
    <br />
    PET works like text but reverses character casing. Any existing mapping list is cleared.<br />
    <br />
    A byte list is treated as a pair of bytes, first the original character, second the replacement byte. A mapping list can be split over several lines.<br />
    <br />
    !text defaults to raw encoding.<br />
    <br />
    <div id="code">
      <br />      !CONVTAB scr
      !text "HELLO WORLD"

      !CT 'A',17,'B',18,'C',19,'D',20,'E',21,'F',22,'G',23,'H',24,'I',25,'J',26,'K',27,'L',28,'M',29,'N',30,'O',31,'P',32,'Q',33,'R',34,'S',35,'T',36
      !CT 'U',37,'V',38,'W',39,'X',40,'Y',41,'Z',42,'0',5,'1',6,'2',7,'3',8,'4',9,'5',10,'6',11,'7',12,'8',13,'9',14,'*',0,' ',16,'.',113

      !text "HELLO WORLD AGAIN"
    </div>
    <br />
    <br />
  </div>
  <a name="cpu"></a>
  <H2>!CPU &lt;cpu type&gt;</H2>
  <div id="mybody">
    This pseudo op sets the processor to assemble for. Currently there are four supported processors. Default is 6510.<br />
    <br />
    * 6502 - 6502 without illegal opcodes<br />
    * 6510 - Default 6510 with illegal opcodes (used e.g. in C64)<br />
    * 65C02 - 6502 with BRA, PHX/Y, PLX/Y, STZ, TRB/TSB<br />
    * R65C02 - 65C02 with BBRx, BBSx, RMBx, SMBx<br />
    * W65C02 - WDC 65C02<br />
    * 65CE02<br />
    * 4502<br />
    * M65 - 4502 with long and quad mode using prefixes (used e.g. in Mega65)<br />
    * 65816 (also known as W65C816S or 65C816)<br />
    * Z80<br />
    * 68000<br />
    <br />
    <br />
    <div id="code">
      <br />      !cpu 6510
    </div>
    <br />
    <br />
  </div>
  <a name="dword"></a>
  <H2>!DWORD, !32, !LE32, !BE32</H2>
  <div id="mybody">
    This pseudo op allows to insert a double word (4 bytes) at the current location.<br />
    <br />
    Allowed are constant values, expressions and labels as content.<br />
    Constant values can be set as decimal, hexadecimal (with prefixed $).<br />
    Labels are treated as 32-bit values. Default is little endian, unless !BE32 is used.<br />
    Expressions are evaluated during the final pass. They must evaluate to a valid word value.<br />
    <br />
    <br />
    <div id="code">
      <br />      !dword 128,270,320
      !32 NoBehaviour
      !le32 ( SCREEN_CHAR + 40 )
    </div>
    <br />
    <br />
  </div>
  <a name="end"></a>
  <H2>!END</H2>
  <div id="mybody">
    This pseudo op specifies the end of a !FOR or !MACRO function.<br />
    <br />
    <br />
  </div>
  <a name="eof"></a><a name="endoffile"></a>
  <H2>!ENDOFFILE, !EOF</H2>
  <div id="mybody">
    This pseudo op ends the parsing of the file at the current line.<br />
    <br />
    <div id="code">
      <br />      rts

      !endoffile

      This file is a carefully handcrafted demo
    </div>
    <br />
    <br />
  </div>
  <a name="error"></a>
  <H2>!ERROR, !SERIOUS &lt;message&gt;</H2>
  <div id="mybody">
    This pseudo op adds an error message to the compile result, essentially breaking the build. The message can be any combination of strings and expressions. Expressions are evaluated where possible.<br />
    <br />
    This pseudo op can be useful inside conditional pseudo op statements to do safety checking.<br />
    <br />
    <br />
    <div id="code">
      <br />      !error "File is ", CODE_END - CODE_START, " bytes long, longer than 2048 bytes!"
    </div>
    <br />
    <br />
  </div>
  <a name="for"></a>
  <H2>!FOR &lt;Variable&gt; = &lt;Start Value Expression&gt; TO &lt;End Value Expression&gt; [STEP &lt;Step Value Expression&gt;]</H2>
  <div id="mybody">
    This pseudo op starts a for loop. To end a for loop specify !END<br />
    <Variable>
      can be global or local (local starts with a dot)<br />
      Start value, end value and step value are treated as expressions.<br />
      <br />
      <br />
      <div id="code">
        <br />      !for ROW = 0 TO 24
        lda BACK_BUFFER + ROW * 40
        sta SCREEN_CHAR + ROW * 40
        !end
      </div>
      <br />
      <br />
    </Variable>
  </div>
  <a name="fill"></a><a name="fi"></a>
  <H2>
    !FILL, !FI &lt;count&gt;[,&lt;value&gt;]<br />
    !FILL, !FI &lt;count&gt;,[expression (list)]
  </H2>
  <div id="mybody">
    This pseudo op fills the given value count times at the current location.<br />
    The expression form can be a list, several expressions are separated by comma. !fill uses every element of a list after each other, and restarts at the first element if required.
    The calculation is evaluated for every byte. The expression inside the brackets uses the label "i" as index, counting the usage of the full list. Any global "i" label is suspended inside the brackets and restored afterwards.<br />
    <br />
    <b>Example #1 - simple fill</b><br />
    <br />
    <div id="code">
      <br />      !fill 8
    </div>
    <br />
    Fills 8 bytes with value zero.<br />
    <br />

    <b>Example #2 - simple fill with value</b><br />
    <br />
    <div id="code">
      <br />      !fill 8,$ff
    </div>
    <br />
    Fills 8 bytes with value $ff.<br />
    <br />

    <b>Example #3 - fill with expression</b><br />
    <br />
    <div id="code">
      <br />      !fill 5, [i * 3]
    </div>
    <br />
    Fills 5 bytes, with values 0, 3, 6, 9, 12.<br />
    <br />

    <b>Example #4 - fill with list</b><br />
    <br />
    <div id="code">
      <br />      !fill 4, [0,i]
    </div>
    <br />
    Fills 4 * 2 bytes, with values 0, 0, 0, 1, 0, 2 0, 3.<br />
    <br />
    <br />
  </div>
  <a name="hex"></a><a name="h"></a>
  <H2>!HEX, !H &lt;hex data&gt;</H2>
  <div id="mybody">
    This pseudo op interprets the rest of the line as hex data, no commas or prefixes like $ or 0x. Data may be separated by spaces, but pairs need to be intact.<br />
    <br />
    <br />
    <div id="code">
      <br />      !hex f0 f1 f2 f3
      !h f0f1f2f3
    </div>
    <br />
    <br />
  </div>
  <a name="ifdef"></a><a name="if"></a>
  <H2>!IF, !IFDEF &lt;expression&gt; {</H2>
  <div id="mybody">
    This pseudo op starts an conditional block. The conditional block is only evaluated if the expression yields a result not equal to zero. The opening curly brace must be on the same line.<br />
    <br />
    !IF checks if the expression is not equal zero, !IFDEF only checks if the expression is defined at all.<br />
    <br />
    A conditional block has to end with a closing curly brace. An optional else or else if statement may open an opposite conditional block, however it must be stated on one line.<br />
    <br />
    <div id="code">
      <br />      !ifdef MUSIC_PLAYING{
      ;initialise music player
      ldx #0
      ldy #0
      lda #MUSIC_TITLE_TUNE
      jsr MUSIC_PLAYER
      } else if SFX_PLAYING {
      ;start sfx engine
      lda #0
      jsr SFX_PLAYER
      } else {
      lda #7
      sta VIC_BORDER_COLOR
      }
    </div>
    <br />
    <br />
  </div>
  <a name="ifndef"></a>
  <H2>!IFNDEF &lt;expression&gt; {</H2>
  <div id="mybody">
    This pseudo op starts an conditional block. The conditional block is only evaluated if the expression yields a result of zero. The opening curly brace must be on the same line.<br />
    <br />
    A conditional block has to end with a closing curly brace. An optional else or else if statement may open an opposite conditional block, however it must be stated on one line.<br />
    <br />
    <div id="code">
      <br />      !ifndef COMPILE_CRUNCHED {
      CHARSET
      !binary "soulless1.chr"
      !binary "soulless2.chr"

      CHARSET_PANEL
      !binary "panel.chr"

      SPRITES
      !binary "soulless.spr"
      } else if COMPILE_FOR_TAPE {
      lda #1
      sta AUTO_LOAD
      } else {
      lda #0
      sta AUTO_LOAD
      }
    </div>
    <br />
    <br />
  </div>
  <a name="jumplist"></a>
  <H2>!JUMPLIST &lt;Label&gt;</H2>
  <div id="mybody">
    This pseudo op allows the building of jump lists (direct word entries), and referencing entry offsets by label name.<br />
    <br />
    <br />
    <div id="code">
      <br />      ;actual routines
Routine1
      lda #0
      rts
Routine2
      lda #1
      rts
Routine3
      lda #2
      rts

      ;jump table (with optional extra data)
      ;<= this global label starts a new zone, !jumptable references the last global label above)
RoutinesPtrs
      !jumptable Routine1       ;lo byte of Routine1, hi byte of Routine1
      !byte 1,2,3,4
      !jumptable Routine2
      !jumptable Routine3

Sequence
      !byte RoutinesPtrs.Routine1  ;= 0
      !byte 10,11,12
      !byte RoutinesPtrs.Routine3  ;= 8
      !byte 20,21,22
      !byte RoutinesPtrs.Routine2  ;= 6
      !byte 30,31,32
    </div>
    <br />
    <br />
  </div>
  <a name="list"></a>
  <H2>!LIST &lt;on/off&gt;</H2>
  <div id="mybody">
    This pseudo op allows to suppress output in preprocessed files. Use !list on to turn on, and !list off to turn off.<br />
    <br />
    <br />
    <div id="code">
      <br />      !list off
    </div>
    <br />
    <br />
  </div>
  <a name="lzone"></a>
  <H2>!LZONE &lt;zone/label name&gt;</H2>
  <div id="mybody">
    This pseudo op declares a new zone plus a global label with the same name. Any local labels (labels starting with '.') are only accessible inside their containing zone.<br />
    <br />
    <br />
    <div id="code">
      <br />      !lzone MainZone
      .locallabel
      ...
      !zone SubZone
      .locallabel
    </div>
    <br />
    <br />
  </div>
  <a name="macro"></a>
  <H2>!MACRO &lt;Function Name&gt; [&lt;Parameter 1&gt;[,&lt;Parameter 2&gt;],..]</H2>
  <div id="mybody">
    This pseudo op defines a macro function. To end the body of a function specify !END<br />
    The number of parameters is variable. Optionally a !macro definition may also be encapsulated by {, } curly braces.<br />
    <br />
    To call a macro use +&lt;Function Name&gt; [&lt;Parameter 1&gt;[,&lt;Parameter 2&gt;],..]<br />
    <br />
    <br />
    <div id="code">
      <br />      !macro fill5bytes v1,v2,v3,v4,v5
      lda #v1
      sta 1024
      lda #v2
      sta 1025
      lda #v3
      sta 1026
      lda #v4
      sta 1027
      lda #v5
      sta 1028
      !end

      !macro fill3bytes v1,v2,v3 {
      lda #v1
      sta 1064
      lda #v2
      sta 1065
      lda #v3
      sta 1066
      }

      lda #$01
      sta $d021

      +fill5bytes 10,20,30,40,50
      +fill3bytes 17,18,19

      inc $d020
    </div>
    <br />
    <br />
  </div>
  <a name="media"></a>
  <H2>!MEDIA &lt;File name&gt;,&lt;Method&gt;[,&lt;Method Parameters&gt;...]</H2>
  <div id="mybody">
    This pseudo op allows to directly include relevant portions of different binary or project files. Currently the pseudo op supports character files (*.chr), character project files (*.charsetproject),
    sprite files (*.spr), sprite project files( *.spriteproject), character screen project files (*.charsetscreen), graphic screen project files (*.graphicscreen) and map project files (*.mapproject).
    <br />
    Method defines what and in which order to export data. The method depends on the given file.<br />
    <br />
    Method Parameters are optional and determine a subset of the export data as applicable.<br />
    <br />
    <br />
    <table>
      <tr>
        <th>
          File Format
        </th>
        <th>
          Extension
        </th>
        <th>
          Method
        </th>
        <th>
          Method Parameters
        </th>
        <th>
          Export
        </th>
      </tr>
      <tr>
        <td>
          Character File
        </td>
        <td>
          *.chr
        </td>
        <td>
          char
        </td>
        <td>
          None
        </td>
        <td>
          Exports all characters data bytes of the source file (C64 256 * 8, FCM 256 * 64, FCM 16bit 8192 * 64)
        </td>
      </tr>
      <tr>
        <td>
          Character File
        </td>
        <td>
          *.chr
        </td>
        <td>
          char
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count character data bytes starting at Index of the source file
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          char
        </td>
        <td>
          None
        </td>
        <td>
          Exports all characters data bytes of the source file (C64 256 * 8, FCM 256 * 64, FCM 16bit 8192 * 64)
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          char
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count character data bytes starting at Index bytes of the character data
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palette
        </td>
        <td>
          None
        </td>
        <td>
          If NES, exports all palette mappings (4 bytes per mapping)<br />
          Any other mode: Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palette
        </td>
        <td>
          Index, Count
        </td>
        <td>
          If NES, exports count palette mappings (4 bytes per mapping), starting at index.<br />
          Any other mode: Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palettergb
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palettergb
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
          Used for Mega65
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
          Used for Mega65
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Character Project File
        </td>
        <td>
          *.charsetproject
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Sprite File
        </td>
        <td>
          *.spr
        </td>
        <td>
          sprite
          spriteoptimize
        </td>
        <td>
          None
        </td>
        <td>
          Exports all sprite data bytes of the source file (C64 256 * 64, Mega65 Expanded 256 * 168, NCM 256 * 168).
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite File
        </td>
        <td>
          *.spr
        </td>
        <td>
          sprite
          spriteoptimize
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count sprite data bytes starting at Index bytes of the source file
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite File
        </td>
        <td>
          *.spr
        </td>
        <td>
          spritedata
          spritedataoptimize
        </td>
        <td>
          Index, Count, Offset, Number of Bytes
        </td>
        <td>
          Takes the sprite data for Count sprites starting at Index and exports Number of Bytes bytes starting at Offset from there
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          sprite
          spriteoptimize
        </td>
        <td>
          None
        </td>
        <td>
          Exports all sprite data bytes of the source file (C64 256 * 64, Mega65 Expanded 256 * 168, NCM 256 * 168)
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          sprite
          spriteoptimize
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count sprite data bytes starting at Index bytes of the sprite data
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          spritedata
          spritedataoptimize
        </td>
        <td>
          Index, Count, Offset, Number of Bytes
        </td>
        <td>
          Takes the sprite data for Count sprites starting at Index and exports Number of Bytes bytes starting at Offset from there
          If optimize is not set sprite data is padded (C64 aligns sprites to 64 bytes, Mega65 aligns sprites to 192 bytes)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palette
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palette
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palettergb
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palettergb
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Sprite Project File
        </td>
        <td>
          *.spriteproject
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Spritepad Project File
        </td>
        <td>
          *.spd
        </td>
        <td>
          sprite
        </td>
        <td>
          None
        </td>
        <td>
          Exports 256 * 64 bytes of the sprite data
        </td>
      </tr>
      <tr>
        <td>
          Spritepad Project File
        </td>
        <td>
          *.spd
        </td>
        <td>
          sprite
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count * 64 bytes starting at Index * 64 bytes of the sprite data
        </td>
      </tr>
      <tr>
        <td>
          Spritepad Project File
        </td>
        <td>
          *.spd
        </td>
        <td>
          spritedata
        </td>
        <td>
          Index, Count, Offset, Number of Bytes
        </td>
        <td>
          Takes the sprite data for Count sprites starting at Index (*64) and exports Number of Bytes bytes starting at Offset from there
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          char
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen character data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charvert
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen character data, column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          char
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen character data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charvert
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen character data, column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          color
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorvert
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data, column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          color
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorvert
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data, column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charcolor
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen char data<br />
          followed by 40 * 25 bytes of the screen color data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charcolorvert
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen char data<br />
          followed by 40 * 25 bytes of the screen color data<br />
          Both column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charcolor
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen char data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen color data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charcolorvert
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen char data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen color data<br />
          Both column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorchar
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data<br />
          followed by 40 * 25 bytes of the screen char data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorcharvert
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data<br />
          followed by 40 * 25 bytes of the screen char data<br />
          Both column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorchar
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen char data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorcharvert
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen char data<br />
          Both column major
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charset
        </td>
        <td>
          None
        </td>
        <td>
          Exports the data of all characters in the charset
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charset
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count * 8 bytes starting at Index * 8 bytes of the character data
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palette
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palette
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palettergb
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palettergb
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          paletteswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered all reds, then all greens, then all blues. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          None
        </td>
        <td>
          Exports all colors from all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          palettergbswizzled
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports count colors, starting at index, over all palettes, color values ordered as RGB triplets. Color bytes are swizzled (nibbles swapped)
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmap
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmap
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphires
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data interpreted as hires
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphires
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data interpreted as hires<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          screen
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 (1000) bytes of the screen data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          screen
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          color
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 (1000) bytes of the color data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          color
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the color data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreen
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data<br />
          followed by 40 * 25 (1000) bytes of the screen data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphiresscreen
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data interpreted as hires<br />
          followed by 40 * 25 (1000) bytes of the screen data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreen
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphiresscreen
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data interpreted as hires<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreencolor
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data<br />
          followed by 40 * 25 (1000) bytes of the screen data<br />
          followed by 40 * 25 (1000) bytes of the color data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphiresscreencolor
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data interpreted as hires<br />
          followed by 40 * 25 (1000) bytes of the screen data<br />
          followed by 40 * 25 (1000) bytes of the color data
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreencolor
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data<br />
          followed by width * height bytes starting at screen coordinates x,y of the color data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmaphiresscreencolor
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data interpreted as hires<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data<br />
          followed by width * height bytes starting at screen coordinates x,y of the color data<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Value Table Project File
        </td>
        <td>
          *.valuetableproject
        </td>
        <td>
          data
        </td>
        <td>
          None
        </td>
        <td>
          Exports all values as single bytes. Values are capped to the range 0 to 255
        </td>
      </tr>
      <tr>
        <td>
          Value Table Project File
        </td>
        <td>
          *.valuetableproject
        </td>
        <td>
          data
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count values starting with Index as single bytes. Values are capped to the range 0 to 255
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          char
        </td>
        <td>
          None
        </td>
        <td>
          Exports all characters data bytes of the source file (C64 256 * 8, FCM 256 * 64, FCM 16bit 8192 * 64)
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          char
        </td>
        <td>
          Index, Count
        </td>
        <td>
          Exports Count character data bytes starting at Index bytes of the character data
        </td>
      </tr>
    </table>
    <br />
    <br />
    <br />
    <div id="code">
      <br />        ;character sets
      !media "panel.chr",char
      !media "panel.chr",char,10,32
      !media "panel.charsetproject",char
      !media "panel.charsetproject",char,10,32
      !media "stage1.mapproject",char
      !media "stage1.mapproject",char,0,200

      ;sprites
      !media "enemies.spr",sprite
      !media "enemies.spr",sprite,10,96
      !media "enemies.spriteproject",sprite
      !media "enemies.spriteproject",sprite,10,96

      ;text screen
      !media "title.charscreen",char
      !media "title.charscreen",char,10,10,20,5
      !media "title.charscreen",color
      !media "title.charscreen",color,10,10,20,5
      !media "title.charscreen",charcolor
      !media "title.charscreen",charcolor,10,10,20,5
      !media "title.charscreen",colorchar
      !media "title.charscreen",colorchar,10,10,20,5

      ;Bitmap
      !media "intro.graphicscreen",bitmap
      !media "intro.graphicscreen",bitmap,8,8,304,184
      !media "intro.graphicscreen",screen
      !media "intro.graphicscreen",screen,8,8,304,184
      !media "intro.graphicscreen",color
      !media "intro.graphicscreen",color,8,8,304,184
      !media "intro.graphicscreen",bitmapscreen
      !media "intro.graphicscreen",bitmapscreen,8,8,304,184
      !media "intro.graphicscreen",bitmapscreencolor
      !media "intro.graphicscreen",bitmapscreencolor,8,8,304,184
    </div>
    <br />
    <br />
  </div>
  <a name="mediasrc"></a>
  <H2>!MEDIASRC &lt;File name&gt;,&lt;LabelPrefix&gt;,&lt;Method&gt;[,&lt;Method Parameters&gt;...]</H2>
  <div id="mybody">
    This pseudo op allows to include relevant portions of project files as assembly. Currently the pseudo op supports character screen project files (*.charsetscreen), graphic screen project files (*.graphicscreen) and map project files (*.mapproject).
    <br />
    LabelPrefix is prefixed to all generated labels. This allows to reference assembled parts directly.<br />
    <br />
    Method defines what and in which order to export data. The method depends on the given file.<br />
    <br />
    Method Parameters are optional and determine a subset of the export data as applicable.<br />
    <br />
    <br />
    <table>
      <tr>
        <th>
          File Format
        </th>
        <th>
          Extension
        </th>
        <th>
          Method
        </th>
        <th>
          Method Parameters
        </th>
        <th>
          Export
        </th>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          char
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen character data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the binary data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          char
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen character data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the binary data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          color
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the binary data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          color
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the binary data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          charcolor
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen char data as assembly directive.<br />
          followed by 40 * 25 bytes of the screen color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the screen char data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the screen color data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          color
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen char data as assembly directive.<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the screen char data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the screen color data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorchar
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 bytes of the screen color data as assembly directive.<br />
          followed by 40 * 25 bytes of the screen char data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the screen char data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the screen color data.
        </td>
      </tr>
      <tr>
        <td>
          Character Screen Project File
        </td>
        <td>
          *.charscreen
        </td>
        <td>
          colorchar
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen color data as assembly directive.<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen char data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_CHARS is inserted before the screen char data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR is inserted before the screen color data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmap
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmap
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          screen
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 (1000) bytes of the screen data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          screen
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the screen data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          color
        </td>
        <td>
          None
        </td>
        <td>
          Exports 40 * 25 (1000) bytes of the color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_COLOR_DATA is inserted before the screen data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          color
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports width * height bytes starting at screen coordinates x,y of the color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_COLOR_DATA is inserted before the screen data.<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreen
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data as assembly directive.<br />
          followed by 40 * 25 (1000) bytes of the screen data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreen
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data as assembly directive.<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreencolor
        </td>
        <td>
          None
        </td>
        <td>
          Exports 8 * 40 * 25 (8000) bytes of the bitmap data as assembly directive.<br />
          followed by 40 * 25 (1000) bytes of the screen data as assembly directive.<br />
          followed by 40 * 25 (1000) bytes of the color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR_DATA is inserted before the screen data.
        </td>
      </tr>
      <tr>
        <td>
          Graphic Screen Project File
        </td>
        <td>
          *.graphicscreen
        </td>
        <td>
          bitmapscreencolor
        </td>
        <td>
          x,y,width,height
        </td>
        <td>
          Exports 8 * width * height bytes starting at screen coordinates x,y of the bitmap data as assembly directive.<br />
          followed by width * height bytes starting at screen coordinates x,y of the screen data as assembly directive.<br />
          followed by width * height bytes starting at screen coordinates x,y of the color data as assembly directive.<br />
          A label named &lt;LabelPrefix&gt;_BITMAP_DATA is inserted before the bitmap data.<br />
          A label named &lt;LabelPrefix&gt;_SCREEN_DATA is inserted before the screen data.<br />
          A label named &lt;LabelPrefix&gt;_COLOR_DATA is inserted before the screen data.<br />
          x,y, width and height must be multiples of 8
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          tileelements
        </td>
        <td>
          None
        </td>
        <td>
          Exports all tiles as arbitrary sized elements like this:<br />
          &lt;LabelPrefix&gt;NUM_TILES = (number of tiles)<br />
          Label &lt;LabelPrefix&gt;TILE_WIDTH (all tile widths)<br />
          Label &lt;LabelPrefix&gt;TILE_HEIGHT (all tile heights)<br />
          Label &lt;LabelPrefix&gt;TILE_CHARS_LO (low byte of pointer to tile char list)<br />
          Label &lt;LabelPrefix&gt;TILE_CHARS_HI (high byte of pointer to tile char list)<br />
          Label &lt;LabelPrefix&gt;TILE_COLORS_LO (low byte of pointer to tile color list)<br />
          Label &lt;LabelPrefix&gt;TILE_COLORS_HI (high byte of pointer to tile color list)<br />
          Label &lt;LabelPrefix&gt;TILE_CHAR_(tile name) (tile chars of tile)<br />
          Label &lt;LabelPrefix&gt;TILE_COLOR_(tile name) (tile colors of tile)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          tiledata
        </td>
        <td>
          None
        </td>
        <td>
          Exports all tiles as two byte blocks (char/colors) like this:<br />
          Label &lt;LabelPrefix&gt;_&lt;TileIndex&gt;_CHARS (characters of tile)<br />
          Label &lt;LabelPrefix&gt;_&lt;TileIndex&gt;_COLORS (colors of tile)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          tile
        </td>
        <td>
          None
        </td>
        <td>
          Exports all tiles as lookup tables like this:<br />
          &lt;LabelPrefix&gt;NUM_TILES = (number of tiles)<br />
          Label &lt;LabelPrefix&gt;TILE_CHARS_&lt;0..max width - 1&gt_&lt;0..max height - 1&gt; (all tiles chars at x, y)<br />
          Label &lt;LabelPrefix&gt;TILE_COLORS_&lt;0..max width - 1&gt_&lt;0..max height - 1&gt; (all tiles colors at x, y)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          map
        </td>
        <td>
          None
        </td>
        <td>
          Exports all maps as lookup tables like this:<br />
          &lt;LabelPrefix&gt;NUM_MAPS = (number of maps)<br />
          &lt;LabelPrefix&gt;MAP_LIST_LO (low bytes of pointer to map data)<br />
          &lt;LabelPrefix&gt;MAP_LIST_HI (high bytes of pointer to map data)<br />
          Only if at least one map has valid extra data:<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_LO (low bytes of pointer to map extra data)<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_HI (high bytes of pointer to map extra data)<br />
          For every map:<br />
          &lt;LabelPrefix&gt;MAP_&lt;map name&gt; (all tile indices of a map)<br />
          (all extra data bytes of a map)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          mapvertical
        </td>
        <td>
          None
        </td>
        <td>
          Exports all maps as lookup tables like this:<br />
          &lt;LabelPrefix&gt;NUM_MAPS = (number of maps)<br />
          &lt;LabelPrefix&gt;MAP_LIST_LO (low bytes of pointer to map data)<br />
          &lt;LabelPrefix&gt;MAP_LIST_HI (high bytes of pointer to map data)<br />
          Only if at least one map has valid extra data:<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_LO (low bytes of pointer to map extra data)<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_HI (high bytes of pointer to map extra data)<br />
          For every map:<br />
          &lt;LabelPrefix&gt;MAP_&lt;map name&gt; (all tile indices of a map column major)<br />
          (all extra data bytes of a map)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          mapextradata
        </td>
        <td>
          None
        </td>
        <td>
          Exports all map extradata as lookup tables like this:<br />
          &lt;LabelPrefix&gt;NUM_MAPS = (number of maps)<br />
          Only if at least one map has valid extra data:<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_LO (low bytes of pointer to map extra data)<br />
          &lt;LabelPrefix&gt;MAP_EXTRA_DATA_LIST_HI (high bytes of pointer to map extra data)<br />
          For every map:<br />
          &lt;LabelPrefix&gt;MAP_&lt;map name&gt; (all tile indices of a map column major)<br />
          (all extra data bytes of a map)<br />
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          maptile
        </td>
        <td>
          None
        </td>
        <td>
          Exports all tiles and maps. Simply concatenates the output of "tile" and "map"
        </td>
      </tr>
      <tr>
        <td>
          Map Project File
        </td>
        <td>
          *.mapproject
        </td>
        <td>
          mapverticaltile
        </td>
        <td>
          None
        </td>
        <td>
          Exports all tiles and maps. Simply concatenates the output of "tile" and "mapvertical"
        </td>
      </tr>
    </table>
    <br />
    <br />
    <br />
    <div id="code">
      <br />        ;text screen
      !mediasrc "title.charscreen",char
      !mediasrc "title.charscreen",char,10,10,20,5
      !mediasrc "title.charscreen",color
      !mediasrc "title.charscreen",color,10,10,20,5
      !mediasrc "title.charscreen",charcolor
      !mediasrc "title.charscreen",charcolor,10,10,20,5
      !mediasrc "title.charscreen",colorchar
      !mediasrc "title.charscreen",colorchar,10,10,20,5

      ;Bitmap
      !mediasrc "intro.graphicscreen",bitmap
      !mediasrc "intro.graphicscreen",bitmap,8,8,304,184
      !mediasrc "intro.graphicscreen",screen
      !mediasrc "intro.graphicscreen",screen,8,8,304,184
      !mediasrc "intro.graphicscreen",color
      !mediasrc "intro.graphicscreen",color,8,8,304,184
      !mediasrc "intro.graphicscreen",bitmapscreen
      !mediasrc "intro.graphicscreen",bitmapscreen,8,8,304,184
      !mediasrc "intro.graphicscreen",bitmapscreencolor
      !mediasrc "intro.graphicscreen",bitmapscreencolor,8,8,304,184

      ;Maps
      !mediasrc "overworld.map",tileelements
      !mediasrc "overworld.map",tile
      !mediasrc "overworld.map",map
      !mediasrc "overworld.map",tilemap
    </div>
    <br />
    <br />
  </div>
  <a name="message"></a>
  <H2>!MESSAGE &lt;message&gt;</H2>
  <div id="mybody">
    This pseudo op adds a message to the output. The message can be any combination of strings and expressions. Expressions are evaluated where possible.<br />
    <br />
    This pseudo op can be useful to output compile time evaluated values (e.g. size of a code section).<br />
    <br />
    <br />
    <div id="code">
      <br />      !message "The compiled section is ", CODE_END - CODE_START, " bytes long"
    </div>
    <br />
    <br />
  </div>
  <a name="nowarn"></a>
  <H2>!NOWARN &lt;warning code(s)&gt;</H2>
  <div id="mybody">
    This pseudo op temporarily adds the given warnings to the ignore warning list.<br />
    <br />
    The warning codes are expected in the Wxxxx form. To ignore the overlapping segment warning (W0001) call like shown in the sample below.<br />
    <br />
    <br />
    <div id="code">
      <br />      !NOWARN w0001
    </div>
    <br />
    <br />
  </div>
  <a name="pseudopc"></a>
  <H2>!PSEUDOPC &lt;address&gt;</H2>
  <div id="mybody">
    This pseudo op alters the following assembly as if the current memory location was starting with the provided address.<br />
    <br />
    Allowed are constant values, expressions and labels as content. Mainly useful for code that will be copied around or bank switched (cartridge).
    When setting !REALPC the program counter is set to the proper location address again.<br />
    <br />
    <br />
    <div id="code">
      <br />      !PSEUDOPC $0400
      ...
      !REALPC
    </div>
    <br />
    <br />
  </div>
  <a name="realign"></a>
  <H2>!REALIGN &lt;alignaddress&gt;[,&lt;fillvalue&gt;]</H2>
  <div id="mybody">
    This pseudo op fills memory until a full multiple of alignaddress is reached.<br />
    If [fillvalue] is omitted 0 is used.<br />
    <br />
    <br />
    <div id="code">
      <br />      !realign $2       ;wait for even address
      !realign 256      ;align code to page border
    </div>
    <br />
    <br />
  </div>
  <a name="realpc"></a>
  <H2>!REALPC</H2>
  <div id="mybody">
    This pseudo op is the counter part for !PSEUDOPC. The following assembly is used the proper memory location.<br />
    <br />
    When setting !REALPC the program counter is set to the proper location address again after a !PSEUDOPC.<br />
    <br />
    <br />
    <div id="code">
      <br />      !PSEUDOPC $0400
      ...
      !REALPC
    </div>
    <br />
    <br />
  </div>
  <a name="scrxor"></a>
  <H2>!SCRXOR &lt;xor value&gt,...</H2>
  <div id="mybody">
    This pseudo op works exactly like !scr, but allows to specify an expression which is used to XOR the following bytes.<br />
    <br />
    <br />
    <div id="code">
      <br />      !scrxor $55, "HELLO WORLD"
    </div>
    <br />
    <br />
  </div>
  <a name="set"></a>
  <H2>!SET &lt;label&gt; = &lt;expression&gt;</H2>
  <div id="mybody">
    This pseudo op assigns a value or result of an expression to a label. Exactly the same like direct assignment, but an existing label can be reassigned with a different value.<br />
    <br />
    <br />
    <div id="code">
      <br />      !set SCREEN_CHAR = $0400
    </div>
    <br />
    <br />
  </div>
  <a name="skip"></a>
  <H2>!SKIP &lt;expression&gt;</H2>
  <div id="mybody">
    This pseudo op skips over a given number of bytes, it works similar to * = * + &lt;expression&gt;<br />
    <br />
    <br />
    <div id="code">
      <br />      !skip 5 * 20     ;skip 100 bytes forwards
    </div>
    <br />
    <br />
  </div>
  <a name="sl"></a>
  <H2>!SL &lt;file name&gt;[,Flags]</H2>
  <div id="mybody">
    This pseudo op instructs the assembler to write a text file with all labels to the given filename.<br />
    The file is a csv formatted text file, with no header and semicolon as separator.<br />
    There are two columns:<br />
    [Labelname]=$[Value];[Unused]<br />
    <br />
    When the label is not used the content of the second column is set to "unused"<br />
    <br />
    Flags allow fine control of the content of the label file. Flags can be combined by using the pipe symbol. These flags are defined:<br />
    <table>
      <tr>
        <th>
          Define
        </th>
        <th>
          Meaning
        </th>
      </tr>
      <tr>
        <td>
          IGNORE_ASSEMBLER_ID_LABELS
        </td>
        <td>
          Does not include Assembler ID labels<br />
          These are as of now ASSEMBLER_C64STUDIO and ASSEMBLER_RETRODEVSTUDIO
        </td>
      </tr>
      <tr>
        <td>
          IGNORE_LOCAL_LABELS
        </td>
        <td>
          Does not include local labels<br />
          These are any labels that are prefixed with + or -
        </td>
      </tr>
      <tr>
        <td>
          IGNORE_INTERNAL_LABELS
        </td>
        <td>
          Does not include internal labels<br />
          These are any labels that are created by prefixing scope values to macro internal labels
        </td>
      </tr>
      <tr>
        <td>
          IGNORE_UNUSED_LABELS
        </td>
        <td>
          Does not include unused labels
        </td>
      </tr>
    </table>
    <br />
    <br />
    <div id="code">
      <br />      !sl "labels.txt"

      !sl "labels.txt", IGNORE_ASSEMBLER_ID_LABELS

      !sl "labels.txt", IGNORE_ASSEMBLER_ID_LABELS | IGNORE_UNUSED_LABELS
    </div>
    <br />
    <br />
  </div>
  <a name="source"></a>
  <a name="src"></a>
  <H2>!SOURCE &lt;file name&gt;[,once]</H2>
  <div id="mybody">
    This pseudo op includes another source file at the current location. File names are used relative to the file containing the directive.<br />
    <br />
    If the file name is given in &lt;,&gt; the file is searched for in the configured library paths.<br />
    <br />
    If ONCE is given as parameter C64Studio remembers to include the given file only once. Any further include statement (with ONCE) will skip over the file>.<br />
    <br />
    <div id="code">
      <br />      !source "tiles.asm"
      !source &lt;kernal.asm&gt;

      !source "tiles.asm",once
      !source &lt;kernal.asm&gt;,once
    </div>
    <br />
    <br />
  </div>
  <a name="text"></a><a name="tx"></a><a name="scr"></a><a name="pet"></a><a name="raw"></a>
  <H2>!TEXT, !TX, !SCR, !PET, !RAW</H2>
  <div id="mybody">
    This pseudo op allows to insert text, characters, or one ore more bytes at the current location.<br />
    Text literals allow the inclusion of text symbols in squiggly braces. See <a href="basic_macros.html">here</a> for a list. For any macro the PETSCII value is used always, independent from the current used mapping.<br />
    <br />
    Allowed are text literals, character literals, constant values, expressions and labels as content.<br />
    text literals are surrounded by ", character literals by '<br />
    Constant values can be set as decimal, hexadecimal (with prefixed $), chars (surrounded by ' or ").<br />
    Labels are treated as 16-bit values. To get the high or low byte prefix the label with &lt; (low byte) or &gt; (high byte)<br />
    Expressions are evaluated during the final pass. They must evaluate to a valid byte value.<br />
    Any values are subject to being mapped to the currently set conversation table.<br />
    !SCR will insert screen codes, while !PET works like !TEXT, but reverses character casing. !RAW inserts bytes untouched.<br />
    <br />
    !text defaults to raw encoding.<br />
    <br />
    <br />
    <div id="code">
      <br />      !text "HELLO WORLD"
      !text " SCORE",60," 00000000   ",224,224,"         LEVEL",60," 00                    ",225,225,"         LIVES",60," 03 *"
      !text 206,184,191,182,198,196,184,0,203,198,0,202,198,204,191,191,184,202,202,0,0

      !text "{clr}HELLO WORLD"
    </div>
    <br />
    <br />
  </div>
  <a name="to"></a>
  <H2>!TO &lt;file name&gt;,&lt;output type&gt;,[&lt;additional parameters&gt;]</H2>
  <div id="mybody">
    This pseudo op sets the output file name and type. This pseudo op will be overridden by any valid output settings in the element properties.<br />
    <br />
    <br />
    Valid output types are CBM, PLAIN, D64, T64, DSK, TAP, CART8BIN, CART8CRT, CART16BIN, CART16CRT, MAGICDESKBIN, MAGICDESKCRT, MAGICDESK32BIN, MAGICDESK32CRT, MAGICDESK128BIN, MAGICDESK128CRT, MAGICDESK256BIN, MAGICDESK256CRT, MAGICDESK512BIN, MAGICDESK512CRT, MAGICDESK1MBIN, MAGICDESK1MCRT, EASYFLASHBIN, EASYFLASHCRT, RGCDBIN, RGCDCRT, GMOD2BIN, GMOD2CRT, ULTIMAX4BIN, ULTIMAX4CRT, ULTIMAX8BIN, ULTIMAX8CRT, ULTIMAX16BIN, ULTIMAX16CRT, CARTNES <br />
    <br />
    For cartridge and tape/disk formats a derived name is currently inserted in the final file. The name is derived from the filename of the originating source file.<br />
    Some output types require additional parameters.<br />
    <br />
    <table>
      <tr>
        <th>
          Output Type
        </th>
        <th>
          Additional Arguments
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr>
        <td>
          CARTNES
        </td>
        <td>
          4
        </td>
        <td>
          Four numbers which are set in the iNES file header<br />
          1: Number of PRG units (16kB per unit, 0 to 64)<br />
          2: Number of CHR units (8kB per unit, 0 to 64)<br />
          3: Number of mapper (0 to 255)<br />
          4: Mirroring nibble (0 to 15)<br />
        </td>
      </tr>
    </table>
    <br />
    <br />
    <div id="code">
      <br />      !to "jmain.prg",cbm
      !to "cart64banks.crt.bin", magicdeskcrt
    </div>
    <br />
    <br />
  </div>
  <a name="trace"></a>
  <H2>!TRACE &lt;Expression&gt;</H2>
  <div id="mybody">
    This pseudo op allows the tracing of a memory location. The expression is evaluated anew on every pass at this location. The resulting value is treated as address and the byte fetched from the current visible RAM/ROM.
    The value is written to the output window.<br />
    <br />
    This pseudo op will only be processed if the debugger is started, not on normal runs. Note that this pseudo op will cause major slowdowns during debugging.<br />
    <br />
    <br />
    <br />
    <div id="code">
      <br />      !trace VIC_RASTER_POS
    </div>
    <br />
    <br />
  </div>
  <a name="warn"></a>
  <H2>!WARN &lt;message&gt;</H2>
  <div id="mybody">
    This pseudo op adds a warning message to the compile result. The message can be any combination of strings and expressions. Expressions are evaluated where possible.<br />
    <br />
    <br />
    <div id="code">
      <br />      !warning "File is ", CODE_END - CODE_START, " bytes long, longer than 2048 bytes!"
    </div>
    <br />
    <br />
  </div>
  <a name="while"></a>
  <H2>!WHILE&lt;Expression&gt; {</H2>
  <div id="mybody">
    This pseudo op starts a while loop. The expression must be true for the loop to continue. C64Studio automatically aborts assembling if the loop is run over 1000 times.<br />
    <br />
    <br />
    <div id="code">
      a = 5
      !while a > 0 {
        lda #a
        sta SCREEN_CHAR + a
        a = a - 1
      }
    </div>
    <br />
    <br />
  </div>
  <a name="word"></a><a name="wo"></a><a name="16"></a>
  <H2>!WORD, !WO, !16, !LE16, !BE16</H2>
  <div id="mybody">
    This pseudo op allows to insert words (2 bytes) at the current location.<br />
    <br />
    Allowed are constant values, expressions and labels as content.<br />
    Constant values can be set as decimal, hexadecimal (with prefixed $).<br />
    Labels are treated as 16-bit values. Default is little endian, unless !BE16 is used.<br />
    Expressions are evaluated during the final pass. They must evaluate to a valid word value.<br />
    <br />
    <br />
    <div id="code">
      <br />      !word 128,270,320
      !word NoBehaviour
      !word ( SCREEN_CHAR + 40 )
    </div>
    <br />
    <br />
  </div>
  <a name="zone"></a>
  <H2>!ZONE &lt;zone name&gt;</H2>
  <div id="mybody">
    This pseudo op declares a new zone. Any local labels (labels starting with '.') are only accessible inside their containing zone.<br />
    <br />
    <br />
    <div id="code">
      <br />      !zone MainZone
      .locallabel
      ...
      !zone SubZone
      .locallabel
    </div>
    <br />
    <br />
  </div>
</body>
</HTML>
